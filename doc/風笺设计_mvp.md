# 風笺设计

## 设计哲学

我只想设计一个优雅简洁,支持量子安全加密的好玩信使协议,但我不是密码学专家,也不是资深工程师,不能自创加密算法,也无法设计全新的工业结构,所以绝大部分设计我都采用应用多年的工业级方案,剩下需要设计的都搭配GPT和Gemini分析,由我把控最终决定,这样设计一份好玩的信使加密协议

風笺协议基于0信任原则设计

此协议无法对抗国家级对手,但是攻击协议所需要的成本已经被抬得很高了,而这样就已经足够保护绝大多数人了



#### WIND LETTER结构



##### WindBase1024F

为了解决传统 Base64 在配合 Wind Letter 结构时文本过长、一条消息在聊天平台中占用空间过大、观感（视觉效果）较差的问题，我设计了 **WindBase1024F**：使用一组精心挑选的、语义负担极低的繁体生僻汉字作为字表，实现 1024 进制编码。在保证可逆与兼容的前提下，相比 Base64 明显缩短消息长度，使加密消息在聊天场景中更加紧凑、美观。

```
風颩颬颭颮颰颱颲颳颴颵颶颷颸颹颺颻颼颽颾颿飀飁飂飃飄飅飆飇飈飉飋飌颯飊飍
雲電雷霆霄霈霏霑霖霙霜霞霧霪霰霹霽霾
```

#### 收件人标识与隐私模式（Recipient Header Modes）

##### **1. 公开**

简单、传统、兼容性高，但会暴露收件人数与公钥 ID。

- 消息头中直接包含每个接收者的 **公开公钥 ID（KeyID）**，明文可见。
- 每个接收者对应一个 KeyID，外部可直接判断消息的接收人数与身份。
- 会话密钥对所有接收者共享，对每个接收者分别用其公钥加密一份并随消息发送。
- 接收者收到消息后：
  1. 根据 KeyID 精确定位自身对应的加密块；
  2. 使用自己的私钥解封会话密钥；
  3. 使用会话密钥解密正文。


#####  **2. 混淆模式 (Obfuscation Mode)**

在此模式下，协议隐藏收件人的真实数量与身份，外界无法通过流量分析反推接收者信息。

- **核心机制**：
    - 消息头中的 `recipients` 列表包含若干个 **接收者路由标识符 (`rid`)**。
    - 列表由 **真实接收者** 和 **随机生成的诱饵 (Decoys)** 混合、重排组成，外部观察者无法区分真伪。
    - 每个 `rid` 对应一个 `encrypted_key` (被包裹的 CEK)。

- **`rid` 生成逻辑 (抗量子混合指纹)**：
    为了确保在后量子时代依然无法通过破解 ECC 来去匿名化，`rid` 必须由 **ECC** 和 **PQC** 的共享秘密共同派生（AND 逻辑）。
    $$
    rid = \text{Trunc}_{16}( \text{HKDF}( \text{salt="wind"}, \ \text{ikm} = SS_{\text{ECC}} \ || \ SS_{\text{PQ}}, \ \text{info="rid/hybrid"} ) )
    $$
    
    - $SS_{\text{ECC}}$：通过 X25519 计算的共享秘密。
    - $SS_{\text{PQ}}$：通过 ML-KEM-768 封装/解封装得到的共享秘密。
    - **注意**：`rid` 仅用于路由匹配，不用于解密正文。
    
- **接收者匹配流程**：
    
    1. 使用消息头中的 `epk` (X25519 临时公钥) 和对应自己的 `ek` (ML-KEM 密文) 分别计算 $SS_{\text{ECC}}$ 和 $SS_{\text{PQ}}$。
    2. 按照相同公式在本地推导出预期的 `rid`。
    3. 在消息头的 `recipients` 列表中查找是否存在该 `rid`。
4. 若匹配成功，则使用对应的 `encrypted_key` 解密会话密钥 (CEK)。
    
- **混淆填充算法 (Bucket Padding Algorithm)**：
  
    为彻底切断流量分析对 **真实收件人数 $m$** 的推断能力，本协议在混淆模式下采用 **固定分桶 (Buckets)** 策略。将外部可观察到的 `recipients` 列表长度 $S$ 强制对齐到少数离散值，使攻击者只能确定“落在哪个桶”，而无法进一步精确定位 $m$。

    - **参数设定**：
        - **真实人数限制**：$m \le 24$（MVP 协议硬性限制，超过需分包）。
        - **分桶集合**：$Buckets = \{8, 16, 24\}$
        - **协议硬下限**：$Limit_{min} = 8$（即使私聊，也伪装成 8 人）。
        - **协议硬上限**：$Limit_{max} = 24$
        - **说明**：当 $m$ 恰好等于桶容量时，允许诱饵数量 $Count_{decoy}=0$。

    - **计算步骤**：
        1. **输入检查**：若 $m > 24$，拒绝处理或执行分包逻辑。
        2. **计算需求人数 ($need$)**：确保不低于协议硬下限。
            $$
            need = \max(m,\ Limit_{min})
            $$
        3. **向上取整到分桶 ($S$)**：选择满足 $S \ge need$ 的最小桶值。
            $$
            S = \min \{b \in Buckets \mid b \ge need\}
            $$
            *等价逻辑：*
            - 若 $need \le 8$：$S = 8$
            - 若 $8 < need \le 16$：$S = 16$
            - 若 $16 < need \le 24$：$S = 24$
        4. **计算诱饵数量**：
            $$
            Count_{decoy} = S - m \quad (\ge 0)
            $$

    - **附录：分桶策略防御性评估**

        **表 A：S 分桶映射参考 ($m \rightarrow S$)**
        
        | 真实人数 ($m$) | 显示人数 ($S$) | 诱饵数量范围 ($S-m$) |
        | :---: | :---: | :---: |
        | **1 ~ 8** | **8** | **7 ~ 0** |
        | **9 ~ 16** | **16** | **7 ~ 0** |
| **17 ~ 24** | **24** | **7 ~ 0** |
        
        **表 B：攻击者逆向推导表 (观测 $S \rightarrow m$)**
        | 观测显示人数 ($S$) | 可能的真实人数集合 ($m$) | 匿名集大小 | **安全性评价** |
        | :---: | :---: | :---: | :--- |
        | **8** | **{1, 2, ..., 8}** | **8** | **完美防御**。私聊与小群在统计学上完全等价，长期观测无法区分。 |
        | **16** | **{9, 10, ..., 16}** | **8** | 中型群组流量特征统一，无法细分。 |
        | **24** | **{17, 18, ..., 24}** | **8** | 大型群组特征统一，尾部人数不再精确暴露。 |